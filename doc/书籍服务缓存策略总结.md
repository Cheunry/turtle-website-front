# 书籍服务缓存策略总结

## 一、整体架构设计

### 1. 缓存技术栈
- **存储层**：Redis（String + Hash + ZSet）
- **序列化**：Jackson ObjectMapper（手动序列化，避免 Spring Cache 类型问题）
- **缓存模式**：Cache-Aside（旁路缓存）
- **一致性**：最终一致性（通过 TTL 自动过期）

### 2. 设计原则
- **读多写少**：优先缓存高频读接口
- **手动管理**：统一使用 `StringRedisTemplate` + `ObjectMapper`，避免 `@Cacheable` 反序列化问题
- **Pipeline 优化**：批量操作使用 Pipeline 减少网络 RTT
- **动态 TTL**：根据业务特性（连载/完结）设置不同过期时间

---

## 二、各接口缓存策略详解

### 1. 章节内容读取 (`getBookContentAbout`)
- **缓存 Key**：`bookContentCache::content:{bookId}:{chapterNum}`
- **数据结构**：Redis String (JSON)
- **TTL 策略**：
  - 连载中：12 小时
  - 已完结：7 天
- **实现**：手动序列化/反序列化，支持 `LocalDateTime`
- **性能**：单次查询，无需 Pipeline

### 2. 章节目录列表 (`getBookChapter`)
- **缓存 Key**：`bookChapterCache::{bookId}`
- **数据结构**：Redis String (JSON Array)
- **TTL 策略**：
  - 连载中：1 小时（快速看到新章节）
  - 已完结：7 天
- **实现**：使用 `TypeReference<List<BookChapterRespDto>>` 处理泛型

### 3. 书籍详情页 (`getBookById`)
- **缓存 Key**：`Cache::Novel::book_info:{bookId}`
- **数据结构**：Redis Hash（兼容榜单预热数据）
- **TTL**：1 小时（冷门书籍自动过期）
- **优化**：使用 Pipeline 合并 `HMSET` + `EXPIRE`（2 次 IO → 1 次）
- **回写策略**：Cache-Aside，查库后自动回写

### 4. 首页推荐 (`listHomeBook`)
- **缓存 Key**：`homeBookCache`
- **数据结构**：Redis String (JSON Array)
- **TTL**：24 小时
- **特点**：全局单 Key，后台配置更新后需手动清除

### 5. 相关推荐 (`listRecBooks`)
- **缓存 Key**：`bookRecCache::{bookId}`
- **数据结构**：Redis String (JSON Array)
- **TTL**：24 小时
- **特点**：按书籍维度缓存，同类推荐结果

### 6. 点击榜单 (`listVisitRankBooks`)
- **缓存 Key**：
  - ZSet：`Cache::Novel::visit_rank`（排名）
  - Hash：`Cache::Novel::book_info:{bookId}`（详情）
- **数据结构**：Redis ZSet + Hash
- **预热机制**：定时任务每 2 分钟刷新 Top 100
- **优化**：Pipeline 批量读取 30 本书详情（31 次 IO → 2 次）

### 7. 访问量统计 (`addVisitCount`)
- **缓存 Key**：
  - ZSet：`Cache::Novel::visit_rank`（实时排名）
  - Hash：`Cache::Novel::book_visit_buffer`（批量刷库缓冲）
- **优化**：Pipeline 合并 `ZINCRBY` + `HINCRBY`（2 次 IO → 1 次）
- **降级**：Redis 异常时直接写库 + 发 MQ

---

## 三、核心技术优化点

### 1. Pipeline 批量操作
```java
// 示例：批量读取榜单详情（30本书）
stringRedisTemplate.executePipelined((RedisCallback<Object>) connection -> {
    for (String bookId : bookIdSet) {
        connection.hGetAll(serializer.serialize(key));
    }
    return null;
});
```
- **效果**：31 次网络往返 → 2 次（查 ZSet + Pipeline 批量查 Hash）

### 2. 动态 TTL 策略
```java
// 根据书籍状态设置不同过期时间
long ttl = bookInfo.getBookStatus() == 1 ? 604800L : 43200L; // 7天 vs 12小时
```
- **收益**：完结书缓存时间更长，减少 DB 压力

### 3. 类型安全序列化
- **问题**：`@Cacheable` 在反序列化 `RestResp<T>` 时可能失败
- **解决**：手动使用 `ObjectMapper` + `TypeReference`，确保类型正确
- **关键**：所有 DTO 必须包含 `@NoArgsConstructor`（配合 `@Builder` 使用）

### 4. 异常处理与降级
- **缓存解析失败**：`log.warn` 记录，降级查库
- **缓存写入失败**：`log.error` 记录，不影响主流程
- **Redis 异常**：访问量统计降级为直接写库 + MQ

---

## 四、缓存命中率监控

### 日志输出
- **命中**：`>>> 章节内容命中 Redis 缓存，bookId={}, chapterNum={}`
- **未命中**：`>>> 章节内容未命中缓存，回源查询 DB，bookId={}, chapterNum={}`
- **写入**：`>>> 章节内容已写入 Redis，key={}，ttl={}s`

### 监控指标建议
- 缓存命中率（通过日志统计）
- Redis 内存使用率
- 缓存写入失败率
- Pipeline 批量操作耗时

---

## 五、缓存失效策略

### 1. TTL 自动过期
- 章节内容：12h / 7d（动态）
- 目录：1h / 7d（动态）
- 详情页：1h
- 首页推荐：24h
- 相关推荐：24h

### 2. 主动清除（待实现）
- 书籍更新时：清除详情页、目录、内容缓存
- 章节发布时：清除目录缓存
- 首页配置更新：清除首页推荐缓存

---

## 六、面试回答要点

### 1. 为什么选择手动缓存而不是 `@Cacheable`？
- **类型安全**：手动序列化可精确控制类型，避免 `RestResp<T>` 反序列化问题
- **灵活控制**：可自定义 Key、TTL、异常处理
- **性能优化**：可配合 Pipeline 批量操作

### 2. 如何解决缓存穿透？
- **现状**：通过业务校验（审核状态）过滤无效请求
- **可优化**：对不存在的书籍 ID 缓存空值（布隆过滤器）

### 3. 如何解决缓存雪崩？
- **策略**：动态 TTL + 随机过期时间（可进一步优化）
- **降级**：缓存异常时直接查库，保证可用性

### 4. Pipeline 优化的收益？
- **访问量统计**：2 次 IO → 1 次（减少 50% 网络开销）
- **榜单查询**：31 次 IO → 2 次（减少 93% 网络开销）
- **详情页回写**：2 次 IO → 1 次（减少 50% 网络开销）

### 5. 如何保证缓存一致性？
- **最终一致性**：通过 TTL 自动过期
- **写后删除**：书籍/章节更新时主动清除相关缓存（待实现）

---

## 七、待优化项

1. **缓存预热**：启动时预热热门书籍的详情和目录
2. **主动失效**：书籍/章节更新时通过 MQ 清除缓存
3. **布隆过滤器**：防止缓存穿透（无效 bookId 查询）
4. **多级缓存**：本地缓存（Caffeine）+ Redis（已在 `CacheConsts` 中定义，未使用）
5. **监控告警**：缓存命中率、Redis 内存使用率

---

## 八、总结

- **覆盖范围**：核心读接口已全部缓存
- **性能优化**：Pipeline 批量操作显著减少网络开销
- **策略灵活**：动态 TTL 适配不同业务场景
- **可维护性**：统一的手动缓存管理，日志完善
- **可扩展性**：预留了多级缓存和主动失效的扩展点

该方案在“读多写少”场景下能显著降低数据库压力，提升系统吞吐量。